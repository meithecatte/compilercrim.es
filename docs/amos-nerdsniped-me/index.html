<!DOCTYPE html>
<html lang="en">
    
        
    
    
        
    
    <head>
        <link rel="stylesheet" href="https://compilercrim.es/style.css?2"/>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
        <title>Terminating the terminal case of Linux</title>
        <link rel="icon" href="https://compilercrim.es/icon.png"/>
        <link rel="canonical" href="https:&#x2F;&#x2F;compilercrim.es&#x2F;amos-nerdsniped-me&#x2F;"/>
        <link rel="alternate" type="application/rss+xml" title="compiler crimes :3" href="/rss.xml">
        
<meta property="og:type" content="article">

        <meta property="og:title" content="Terminating the terminal case of Linux">
        
            <meta property="og:description" content="I remember it like it was yesterday. It was a very calm and pleasant evening,
when, all of a sudden, amos the fasterthanlime published
an article entitled &quot;A terminal case of Linux&quot;. With a title that makes you sigh when you get it, he explains his adventure of capturing colored terminal output of a Linux process.
After a journey through the bowels of libc, the Land of Terrible Truths, and as
is in Amos&#x27;s style, many underlying details of the problem, we arrive at a
program that does what we&#x27;ve set out to do. Well, almost.&amp;hellip;

">
        
        <meta property="og:url" content="https:&#x2F;&#x2F;compilercrim.es&#x2F;amos-nerdsniped-me&#x2F;">
        <meta property="og:image" content="https://compilercrim.es/icon.png">
    </head>
    <body class="theme-default">
        <header>
            <div class="main-column">
                <a href="/">
                    <img id="icon" src="/icon.png">
                    <span class="head-backdrop">the blog of compiler crime :3</span>
                </a>
            </div>
        </header>
        <main>
            <article>
                
<h1 class="title">
  Terminating the terminal case of Linux
</h1>

<p class="page-metadata">
September 25, 2021
&middot; 8 minute read
</p>



<p>I remember it like it was yesterday.<sup class="footnote-reference"><a href="#yesterday">1</a></sup> It was a very calm and pleasant evening,
when, all of a sudden, amos the fasterthanlime published
an article entitled <a href="https://fasterthanli.me/articles/a-terminal-case-of-linux">"A terminal case of Linux"</a>. With a title that makes you sigh when you get it, he explains his adventure of capturing colored terminal output of a Linux process.</p>
<p>After a journey through the bowels of libc, the Land of Terrible Truths, and as
is in Amos's style, many underlying details of the problem, we arrive at a
program that does what we've set out to do. Well, almost. <span id="continue-reading"></span></p>
<p>You see, in a devious act of nerdsnipe, the article stops when there's still one
problem to solve:</p>
<p><img src="https://compilercrim.es/amos-nerdsniped-me/quote.png" alt="Cool bear: Nice, nice... but what&#39;s that ^C at the end? / Amos: Nothing. / Bear: What? / Amos: IT&#39;S NOTHING. It&#39;s an exercise left to the reader. / Bear: But doesn&#39;t that mean we- /Amos: So the program hangs at the end of main. Big deal. We could just call std::process::exit! That would definitely cut things short." /></p>
<blockquote>
<p>🤔 I sure do envy Amos's relationship with Cool Bear. I'd look into
getting such a sidekick myself, but the dorm I'm about to move into doesn't
allow keeping pets, and definitely not ones sentient enough to throw a party.</p>
</blockquote>
<p>Well, <a href="/bootstrap/miniforth/#ref:stack-complete">I've been guilty of setting such exercises for my readers
too</a>, so today, we'll be solving one of those instead.</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>[.../compilercrim.es/content/amos-nerdsniped-me]$ cargo new terminus
</span><span>Created binary (application) `terminus` package
</span></code></pre>
<p>First order of business: reproducing the bug. We add the dependencies...</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ cargo add libc
</span><span>$ cargo add tokio@1.12.0 --features full
</span></code></pre>
<p>...paste in the code...</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f92672;">use </span><span>std::{error::Error, os::unix::prelude::FromRawFd};
</span><span style="color:#f92672;">use </span><span>tokio::{fs::File, io::AsyncReadExt, process::Command};
</span><span>
</span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">openpty</span><span>() -&gt; (</span><span style="font-style:italic;color:#66d9ef;">i32</span><span>, </span><span style="font-style:italic;color:#66d9ef;">i32</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> primary_fd: </span><span style="font-style:italic;color:#66d9ef;">i32 </span><span style="color:#f92672;">= -</span><span style="color:#ae81ff;">1</span><span>;
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> secondary_fd: </span><span style="font-style:italic;color:#66d9ef;">i32 </span><span style="color:#f92672;">= -</span><span style="color:#ae81ff;">1</span><span>;
</span><span>    </span><span style="color:#f92672;">unsafe </span><span>{
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> ret </span><span style="color:#f92672;">= </span><span>libc::openpty(
</span><span>            </span><span style="color:#f92672;">&amp;mut</span><span> primary_fd,
</span><span>            </span><span style="color:#f92672;">&amp;mut</span><span> secondary_fd,
</span><span>            std::ptr::null_mut(),
</span><span>            std::ptr::null(),
</span><span>            std::ptr::null(),
</span><span>        );
</span><span>        </span><span style="color:#f92672;">if</span><span> ret </span><span style="color:#f92672;">!= </span><span style="color:#ae81ff;">0 </span><span>{
</span><span>            panic!(</span><span style="color:#e6db74;">&quot;Failed to openpty!&quot;</span><span>);
</span><span>        }
</span><span>    };
</span><span>    (primary_fd, secondary_fd)
</span><span>}
</span><span>
</span><span>#[tokio::main]
</span><span>async </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">main</span><span>() -&gt; </span><span style="font-style:italic;color:#66d9ef;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#66d9ef;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span>(primary_fd, secondary_fd) </span><span style="color:#f92672;">= </span><span style="color:#66d9ef;">openpty</span><span>();
</span><span>    dbg!(primary_fd, secondary_fd);
</span><span>
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> cmd </span><span style="color:#f92672;">= </span><span>Command::new(</span><span style="color:#e6db74;">&quot;/bin/bash&quot;</span><span>);
</span><span>    cmd.</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;-c&quot;</span><span>)
</span><span>        .</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;for i in $(seq 1 3); do cargo check; sleep 0.2; done&quot;</span><span>);
</span><span>
</span><span>    </span><span style="color:#f92672;">unsafe </span><span>{
</span><span>        cmd.</span><span style="color:#66d9ef;">pre_exec</span><span>(</span><span style="color:#f92672;">move || </span><span>{
</span><span>            </span><span style="color:#f92672;">if </span><span>libc::login_tty(secondary_fd) </span><span style="color:#f92672;">!= </span><span style="color:#ae81ff;">0 </span><span>{
</span><span>                panic!(</span><span style="color:#e6db74;">&quot;couldn&#39;t set the controlling terminal or something&quot;</span><span>);
</span><span>            }
</span><span>            </span><span style="font-style:italic;color:#66d9ef;">Ok</span><span>(())
</span><span>        })
</span><span>    };
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> child </span><span style="color:#f92672;">=</span><span> cmd.</span><span style="color:#66d9ef;">spawn</span><span>()</span><span style="color:#f92672;">?</span><span>;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> out </span><span style="color:#f92672;">= </span><span>vec![];
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> buf </span><span style="color:#f92672;">= </span><span>vec![</span><span style="color:#ae81ff;">0</span><span style="font-style:italic;color:#66d9ef;">u8</span><span>; </span><span style="color:#ae81ff;">1024</span><span>];
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> primary </span><span style="color:#f92672;">= unsafe </span><span>{ File::from_raw_fd(primary_fd) };
</span><span>
</span><span>    &#39;weee: </span><span style="color:#f92672;">loop </span><span>{
</span><span>        tokio::select</span><span style="color:#f92672;">! </span><span>{
</span><span>            n </span><span style="color:#f92672;">=</span><span> primary.</span><span style="color:#66d9ef;">read</span><span>(</span><span style="color:#f92672;">&amp;mut</span><span> buf) </span><span style="color:#f92672;">=&gt; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#66d9ef;">let</span><span> n </span><span style="color:#f92672;">=</span><span> n</span><span style="color:#f92672;">?</span><span>;
</span><span>                println!(</span><span style="color:#e6db74;">&quot;Read </span><span style="color:#ae81ff;">{}</span><span style="color:#e6db74;"> bytes&quot;</span><span>, n);
</span><span>                out.</span><span style="color:#66d9ef;">extend_from_slice</span><span>(</span><span style="color:#f92672;">&amp;</span><span>buf[</span><span style="color:#f92672;">..</span><span>n]);
</span><span>            },
</span><span>
</span><span>            status </span><span style="color:#f92672;">=</span><span> child.</span><span style="color:#66d9ef;">wait</span><span>() </span><span style="color:#f92672;">=&gt; </span><span>{
</span><span>                status</span><span style="color:#f92672;">?</span><span>;
</span><span>                println!(</span><span style="color:#e6db74;">&quot;Child exited!&quot;</span><span>);
</span><span>                </span><span style="color:#f92672;">break &#39;weee
</span><span>            },
</span><span>        }
</span><span>    }
</span><span>    println!(</span><span style="color:#e6db74;">&quot;</span><span style="color:#ae81ff;">{}</span><span style="color:#e6db74;">&quot;</span><span>, </span><span style="font-style:italic;color:#66d9ef;">String</span><span>::from_utf8(out)</span><span style="color:#f92672;">?</span><span>);
</span><span>
</span><span>    println!(</span><span style="color:#e6db74;">&quot;Ok we&#39;re gonna return now&quot;</span><span>);
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<p>and...</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ cargo run -q
</span><span>[src/main.rs:25] primary_fd = 9
</span><span>[src/main.rs:25] secondary_fd = 10
</span><span>Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</span></code></pre>
<p>Uhh, what? That's not what was supposed to happen. The one time you chose to
skip the error handling, Amos!</p>
<p>Hmm, we could add some error tracing ourselves, or...</p>
<p><em>squints</em></p>
<p>Ah, I see. This is because I am a masochist...</p>
<blockquote>
<p>...and this is the point where Bear would chime in, with some snarky remark like
"as if <a href="/bootstrap/">we didn't know that already</a>". See? I'd be good at this.
Where do I apply for a bear-ing license?</p>
</blockquote>
<p><em>ahem</em>, because I am a masochist and run <a href="https://nixos.org/">NixOS</a> as my daily
driver distro. This means that <code>/bin</code> looks like it's been deserted:</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ ls /bin
</span><span>sh
</span></code></pre>
<p>No such luck in <code>/usr/bin</code> either:</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ ls /usr/bin
</span><span>env
</span></code></pre>
<p>What are you looking at? It's POSIX compliant. If you want to find <code>bash</code>,
you'll need to scan through <code>$PATH</code> or something.</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ which bash
</span><span>/run/current-system/sw/bin/bash
</span><span>
</span><span>$ realpath $(which bash)
</span><span>/nix/store/39k586qrghljxiyqvv72ni5fk89vshib-bash-interactive-4.4-p23/bin/bash
</span></code></pre>
<p>This means that shebang lines are often something like <code>#!/usr/bin/env bash</code>, if
you need the bash features. But apart from that (and the fact that I connect to new Wi-Fi networks
by editing a config file and then running <code>nixos-rebuild switch</code>, which takes a
few minutes (and the fact that getting random executables downloaded from the
internet is hard)), it's <em>great</em> — it's like Haskell, Bash and Unix had a
threesome and the birth control didn't quite work.</p>
<p>In this case, we should be able to get away with...</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> cmd </span><span style="color:#f92672;">= </span><span>Command::new(</span><span style="color:#e6db74;">&quot;/bin/sh&quot;</span><span>); </span><span style="color:#85817e;">// was /bin/bash
</span><span>    cmd.</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;-c&quot;</span><span>)
</span><span>        .</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;for i in $(seq 1 3); do cargo check; sleep 0.2; done&quot;</span><span>);
</span></code></pre>
<p>...and we can observe the bug!</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>    [...]
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 20.17s
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
</span><span>
</span><span>Ok we&#39;re gonna return now
</span><span>^C
</span></code></pre>
<p>So, how is it even possible that we're returning from main and the process isn't
exiting?</p>
<p>You might think of the code provided by <code>std</code> that takes us from <code>_start</code> to <code>main</code> and vice versa, but today we won't need to go that deep.
The secret is that, the <code>main</code> we can see in our code is not the <em>true</em> <code>main</code>. See this little attribute macro?</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[tokio::main]
</span><span>async </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">main</span><span>() -&gt; </span><span style="font-style:italic;color:#66d9ef;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#66d9ef;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span></code></pre>
<p>Macros like that are allowed to do whatever changes they want to the tokens of
the item they're applied to. Let's see what the docs have to say about this
particular one, then:</p>
<blockquote>
<p>Marks async function to be executed by the selected runtime. This macro helps set up a <code>Runtime</code> without requiring the user to use <code>Runtime</code> or <code>Builder</code> directly.</p>
<p>[...]</p>
<p>Note: This macro can be used on any function and not just the main function. Using it on a non-main function makes the function behave as if it was synchronous by starting a new runtime each time it is called. If the function is called often, it is preferable to create the runtime using the runtime builder so the runtime can be reused across calls.</p>
</blockquote>
<p>If we wanted to, we could even take a look at the code it generates with <a href="https://crates.io/crates/cargo-expand"><code>cargo expand</code></a>:</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f92672;">$</span><span> cargo expand main
</span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">main</span><span>() -&gt; </span><span style="font-style:italic;color:#66d9ef;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#66d9ef;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    tokio::runtime::Builder::new_multi_thread()
</span><span>        .</span><span style="color:#66d9ef;">enable_all</span><span>()
</span><span>        .</span><span style="color:#66d9ef;">build</span><span>()
</span><span>        .</span><span style="color:#66d9ef;">expect</span><span>(</span><span style="color:#e6db74;">&quot;Failed building the Runtime&quot;</span><span>)
</span><span>        .</span><span style="color:#66d9ef;">block_on</span><span>(async {
</span><span>            {
</span><span>                ::std::io::_print(::core::fmt::Arguments::new_v1(
</span><span>                    </span><span style="color:#f92672;">&amp;</span><span>[</span><span style="color:#e6db74;">&quot;Async main says hi!</span><span style="color:#ae81ff;">\n</span><span style="color:#e6db74;">&quot;</span><span>],
</span><span>                    </span><span style="color:#f92672;">&amp;match </span><span>() {
</span><span>                        () </span><span style="color:#f92672;">=&gt; </span><span>[],
</span><span>                    },
</span><span>                ));
</span><span>            };
</span><span>        })
</span><span>}
</span></code></pre>
<p>BTW, if I run <code>cargo expand</code> on the original code, it all gets printed on one
line, even though <code>cargo expand</code> already runs rustfmt here...</p>
<p>The actual code is just as advertised, though — it creates a <code>Runtime</code>, and our
actual code is put in an <code>async</code> block, which is then ran <em>on</em> that <code>Runtime</code>
with <code>block_on</code>. So I guess it gets stuck somewhere in <code>tokio</code>?</p>
<p>Now, through the magic of having wasted way too much time on Twitter, I
know of a neat tool for learning about what's happening within <code>tokio</code> —
the Tokio Console. It's like <code>top</code>, but for async tasks! Let's try it out.</p>
<p>The README opens with</p>
<blockquote>
<p>⚠️ extremely serious warning: this is pre-alpha software undergoing active development! currently, the wire format has no stability guarantees — the crates in this repository are not guaranteed to be interoperable except within the same Git revision. when these crates are published to crates.io, the wire format will follow semver, but currently, anything could happen!</p>
</blockquote>
<p>I suppose that means you can't deploy this to production, at least without
pinning the git commit you use, but for having some fun, it should be fine.</p>
<p>On the side of our program, we need to add the <code>console-subscriber</code> dependency:</p>
<pre data-lang="toml" style="background-color:#272822;color:#c9d1d9;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="color:#85817e;"># in Cargo.toml
</span><span style="color:#f92672;">console-subscriber </span><span>= { </span><span style="color:#f92672;">git </span><span>= </span><span style="color:#e6db74;">&quot;https://github.com/tokio-rs/console&quot; </span><span>}
</span></code></pre>
<p>and call <code>init</code> when we're starting up:</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[tokio::main]
</span><span>async </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">main</span><span>() -&gt; </span><span style="font-style:italic;color:#66d9ef;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#66d9ef;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    console_subscriber::init(); </span><span style="color:#85817e;">// new!
</span></code></pre>
<p>We also have to compile with <code>RUSTFLAGS="--cfg tokio_unstable" cargo build</code>, to
expose the tokio internals from which the data can be collected.</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ RUSTFLAGS=&quot;--cfg tokio_unstable&quot; cargo run
</span></code></pre>
<p><em>drumroll please</em></p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>error: failed to run custom build command for `prost-build v0.8.0`
</span><span>
</span><span>Caused by:
</span><span>  process didn&#39;t exit successfully: `/home/maya/dev/terminus/target/debug/build/prost-build-793fc1bd9d193261/build-script-build` (exit status: 101)
</span><span>  --- stderr
</span><span>  thread &#39;main&#39; panicked at &#39;Failed to find the protoc binary. The PROTOC environment variable is not set, there is no bundled protoc for this platform, and protoc is not in the PATH&#39;, /home/maya/.cargo/registry/src/github.com-1ecc6299db9ec823/prost-build-0.8.0/build.rs:105:10
</span><span>  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</span></code></pre>
<p>Okay, where can I find a <code>protoc</code>?</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ protoc
</span><span>The program &#39;protoc&#39; is not in your PATH. It is provided by several packages.
</span><span>You can make it available in an ephemeral shell by typing one of the following:
</span><span>  nix-shell -p grpc-tools
</span><span>  nix-shell -p protobuf
</span><span>  nix-shell -p protobuf2_5
</span><span>  nix-shell -p protobuf3_1
</span><span>  [about ten other versions elided]
</span></code></pre>
<p>Nice, it's packaged. One <code>nix-shell</code> later, we have a shell with <code>protoc</code>
installed. All the tidyness of using some kind of ephemeral container with the
convenience of installing it globally and hoping it won't break anything.
Definitely worth all the other hassle, don't try to tell me otherwise.</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ nix-shell -p protobuf
</span><span>[nix-shell:~/dev/terminus]$ RUSTFLAGS=&quot;--cfg tokio_unstable&quot; cargo run
</span></code></pre>
<p>This should mean that our program now listens on port 6669, and will send off
precious debug info when we connect. That port, on your local machine, is the
default address for where the Tokio console will connect to:</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ git clone https://github.com/tokio-rs/console tokio-console
</span><span>[...]
</span><span>$ cd tokio-console
</span><span>$ nix-shell -p protobuf # we need to do this again since we&#39;re in a separate terminal
</span><span>[nix-shell:~/dev/tokio-console]$ cargo run
</span></code></pre>
<p>And just like that, we get to peek under the hood. To get a steady readout of
what the normal conditions look like, let's adjust our command so that the
output rate is a bit more predictable:</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> cmd </span><span style="color:#f92672;">= </span><span>Command::new(</span><span style="color:#e6db74;">&quot;/bin/sh&quot;</span><span>);
</span><span>    cmd.</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;-c&quot;</span><span>)
</span><span>        .</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;while true; do echo Hi there; sleep 0.5; done&quot;</span><span>);
</span><span>                </span><span style="color:#85817e;">// no more pesky cargo checks taking only finite time
</span></code></pre>
<p>The console looks like this now:</p>
<p><img src="https://compilercrim.es/amos-nerdsniped-me/console.png" alt="Screenshot of the tokio console, described below." /></p>
<p>Apart from some tasks internal to the console itself, we see many stopped
instances of <code>tokio::task::blocking</code>. "stopped" meaning these are only visible
because, by default, tasks are kept on the screen for two seconds after they've
terminated.</p>
<p>We can see that each of those tasks ran for almost exactly half a second. Looks
like a new task is spawned each time we call <code>read</code>...</p>
<p>And if we trigger the hang bug, we indeed see one such blocking task, and it
stays running. As the controls line at the top of the screen tells us, we can
use the arrow keys and Enter to view some more details about it:</p>
<p><img src="https://compilercrim.es/amos-nerdsniped-me/console2.png" alt="" /></p>
<p>We can see that the task has been busy for about 40 seconds already, and that
the entrypoint of this task was</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f92672;">&lt;</span><span>tokio::fs::file::File </span><span style="color:#f92672;">as </span><span>tokio::io::async_read::AsyncRead</span><span style="color:#f92672;">&gt;</span><span>::poll_read::{{closure}}
</span></code></pre>
<p>Thanks to the <code>[src]</code> links in the documentation, we can easily find <a href="https://docs.rs/tokio/1.12.0/src/tokio/fs/file.rs.html#515-521">the
code</a>.
And it's not pretty.</p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#85817e;">// in src/tokio/fs/file.rs
</span><span>
</span><span style="font-style:italic;color:#66d9ef;">impl </span><span>AsyncRead </span><span style="color:#f92672;">for </span><span>File {
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">poll_read</span><span>(
</span><span>        </span><span style="font-style:italic;color:#fd971f;">self</span><span>: Pin&lt;</span><span style="color:#f92672;">&amp;mut </span><span style="font-style:italic;color:#66d9ef;">Self</span><span>&gt;,
</span><span>        </span><span style="font-style:italic;color:#fd971f;">cx</span><span>: </span><span style="color:#f92672;">&amp;mut </span><span>Context&lt;&#39;</span><span style="color:#f92672;">_</span><span>&gt;,
</span><span>        </span><span style="font-style:italic;color:#fd971f;">dst</span><span>: </span><span style="color:#f92672;">&amp;mut </span><span>ReadBuf&lt;&#39;</span><span style="color:#f92672;">_</span><span>&gt;,
</span><span>    ) -&gt; Poll&lt;io::</span><span style="font-style:italic;color:#66d9ef;">Result</span><span>&lt;()&gt;&gt; {
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> me </span><span style="color:#f92672;">= </span><span>self.</span><span style="color:#66d9ef;">get_mut</span><span>();
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> inner </span><span style="color:#f92672;">=</span><span> me.inner.</span><span style="color:#66d9ef;">get_mut</span><span>();
</span><span>
</span><span>        </span><span style="color:#f92672;">loop </span><span>{
</span><span>            </span><span style="color:#f92672;">match</span><span> inner.state {
</span><span>                Idle(</span><span style="color:#f92672;">ref mut</span><span> buf_cell) </span><span style="color:#f92672;">=&gt; </span><span>{
</span><span>                    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> buf </span><span style="color:#f92672;">=</span><span> buf_cell.</span><span style="color:#66d9ef;">take</span><span>().</span><span style="color:#66d9ef;">unwrap</span><span>();
</span><span>
</span><span>                    </span><span style="color:#f92672;">if !</span><span>buf.</span><span style="color:#66d9ef;">is_empty</span><span>() {
</span><span>                        buf.</span><span style="color:#66d9ef;">copy_to</span><span>(dst);
</span><span>                        </span><span style="color:#f92672;">*</span><span>buf_cell </span><span style="color:#f92672;">= </span><span style="font-style:italic;color:#66d9ef;">Some</span><span>(buf);
</span><span>                        </span><span style="color:#f92672;">return</span><span> Ready(</span><span style="font-style:italic;color:#66d9ef;">Ok</span><span>(()));
</span><span>                    }
</span><span>
</span><span>                    buf.</span><span style="color:#66d9ef;">ensure_capacity_for</span><span>(dst);
</span><span>                    </span><span style="font-style:italic;color:#66d9ef;">let</span><span> std </span><span style="color:#f92672;">=</span><span> me.std.</span><span style="color:#66d9ef;">clone</span><span>();
</span><span>
</span><span>                    inner.state </span><span style="color:#f92672;">=</span><span> Busy(</span><span style="color:#66d9ef;">spawn_blocking</span><span>(</span><span style="color:#f92672;">move || </span><span>{    </span><span style="color:#85817e;">// !
</span><span>                        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> res </span><span style="color:#f92672;">=</span><span> buf.</span><span style="color:#66d9ef;">read_from</span><span>(</span><span style="color:#f92672;">&amp;mut &amp;*</span><span>std);
</span><span>                        (Operation::Read(res), buf)
</span><span>                    }));
</span><span>                }
</span><span>                Busy(</span><span style="color:#f92672;">ref mut</span><span> rx) </span><span style="color:#f92672;">=&gt; </span><span style="color:#85817e;">/* ... */
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>As you can see, when <code>AsyncRead::poll_read</code> gets called, it will use
<code>spawn_blocking</code> to spawn a task on the thread pool, and call the normal,
not-at-all-async <code>std::fs::File</code>'s <code>read</code>.</p>
<p>So much for Tokio being an async I/O library, I guess.</p>
<p>This is our smoking gun. If we try to poll a <code>read</code> future before our child
process exits, but after we've read all its output, Tokio's implementation of
<code>AsyncRead</code> will spawn a blocking task, which will call a classical, blocking
<code>read</code> syscall, which will wait forever for the data that'll never come.</p>
<p><em>sigh</em></p>
<p>Now that I've dug this far, I remember running into this a year ago —
it's a <a href="https://github.com/tokio-rs/tokio/issues/2926">long-standing issue</a> that <em>file</em> I/O isn't actually
asynchronous due to deficiencies in OS APIs, and <a href="https://github.com/tokio-rs/tokio/issues/2466">it's known that it can block
shutdown</a>.</p>
<p>Back when I first hit this, I was on a tight deadline, so I just bodged around
it and forgot. But surely, somebody else with more time on their hands had also
hit this by now.</p>
<p>And, sure enough, the second result for "tokio non-blocking file io" is the
<a href="https://crates.io/crates/tokio-fd"><code>tokio-fd</code> crate</a>.</p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ cargo add tokio-fd
</span><span>    Updating &#39;https://github.com/rust-lang/crates.io-index&#39; index
</span><span>      Adding tokio-fd v0.3.0 to dependencies
</span></code></pre>
<p><em>quick prayer to Ferris</em></p>
<pre data-lang="rust" style="background-color:#272822;color:#c9d1d9;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#f92672;">use </span><span>std::{error::Error, convert::TryFrom};
</span><span style="color:#f92672;">use </span><span>tokio::{io::AsyncReadExt, process::Command};
</span><span style="color:#f92672;">use </span><span>tokio_fd::AsyncFd;
</span><span>
</span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">openpty</span><span>() -&gt; (</span><span style="font-style:italic;color:#66d9ef;">i32</span><span>, </span><span style="font-style:italic;color:#66d9ef;">i32</span><span>) {
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> primary_fd: </span><span style="font-style:italic;color:#66d9ef;">i32 </span><span style="color:#f92672;">= -</span><span style="color:#ae81ff;">1</span><span>;
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> secondary_fd: </span><span style="font-style:italic;color:#66d9ef;">i32 </span><span style="color:#f92672;">= -</span><span style="color:#ae81ff;">1</span><span>;
</span><span>    </span><span style="color:#f92672;">unsafe </span><span>{
</span><span>        </span><span style="font-style:italic;color:#66d9ef;">let</span><span> ret </span><span style="color:#f92672;">= </span><span>libc::openpty(
</span><span>            </span><span style="color:#f92672;">&amp;mut</span><span> primary_fd,
</span><span>            </span><span style="color:#f92672;">&amp;mut</span><span> secondary_fd,
</span><span>            std::ptr::null_mut(),
</span><span>            std::ptr::null(),
</span><span>            std::ptr::null(),
</span><span>        );
</span><span>        </span><span style="color:#f92672;">if</span><span> ret </span><span style="color:#f92672;">!= </span><span style="color:#ae81ff;">0 </span><span>{
</span><span>            panic!(</span><span style="color:#e6db74;">&quot;Failed to openpty!&quot;</span><span>);
</span><span>        }
</span><span>    };
</span><span>    (primary_fd, secondary_fd)
</span><span>}
</span><span>
</span><span>#[tokio::main]
</span><span>async </span><span style="font-style:italic;color:#66d9ef;">fn </span><span style="color:#a6e22e;">main</span><span>() -&gt; </span><span style="font-style:italic;color:#66d9ef;">Result</span><span>&lt;(), </span><span style="font-style:italic;color:#66d9ef;">Box</span><span>&lt;dyn Error&gt;&gt; {
</span><span>    console_subscriber::init();
</span><span>
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span>(primary_fd, secondary_fd) </span><span style="color:#f92672;">= </span><span style="color:#66d9ef;">openpty</span><span>();
</span><span>    dbg!(primary_fd, secondary_fd);
</span><span>
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> cmd </span><span style="color:#f92672;">= </span><span>Command::new(</span><span style="color:#e6db74;">&quot;/bin/sh&quot;</span><span>);
</span><span>    cmd.</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;-c&quot;</span><span>)
</span><span>        .</span><span style="color:#66d9ef;">arg</span><span>(</span><span style="color:#e6db74;">&quot;for i in $(seq 1 3); do cargo check; sleep 0.2; done&quot;</span><span>);
</span><span>
</span><span>    </span><span style="color:#f92672;">unsafe </span><span>{
</span><span>        cmd.</span><span style="color:#66d9ef;">pre_exec</span><span>(</span><span style="color:#f92672;">move || </span><span>{
</span><span>            </span><span style="color:#f92672;">if </span><span>libc::login_tty(secondary_fd) </span><span style="color:#f92672;">!= </span><span style="color:#ae81ff;">0 </span><span>{
</span><span>                panic!(</span><span style="color:#e6db74;">&quot;couldn&#39;t set the controlling terminal or something&quot;</span><span>);
</span><span>            }
</span><span>            </span><span style="font-style:italic;color:#66d9ef;">Ok</span><span>(())
</span><span>        })
</span><span>    };
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> child </span><span style="color:#f92672;">=</span><span> cmd.</span><span style="color:#66d9ef;">spawn</span><span>()</span><span style="color:#f92672;">?</span><span>;
</span><span>
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> out </span><span style="color:#f92672;">= </span><span>vec![];
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> buf </span><span style="color:#f92672;">= </span><span>vec![</span><span style="color:#ae81ff;">0</span><span style="font-style:italic;color:#66d9ef;">u8</span><span>; </span><span style="color:#ae81ff;">1024</span><span>];
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">let </span><span style="color:#f92672;">mut</span><span> primary </span><span style="color:#f92672;">= </span><span>AsyncFd::try_from(primary_fd)</span><span style="color:#f92672;">?</span><span>; </span><span style="color:#85817e;">// new
</span><span>
</span><span>    &#39;weee: </span><span style="color:#f92672;">loop </span><span>{
</span><span>        tokio::select</span><span style="color:#f92672;">! </span><span>{
</span><span>            n </span><span style="color:#f92672;">=</span><span> primary.</span><span style="color:#66d9ef;">read</span><span>(</span><span style="color:#f92672;">&amp;mut</span><span> buf) </span><span style="color:#f92672;">=&gt; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#66d9ef;">let</span><span> n </span><span style="color:#f92672;">=</span><span> n</span><span style="color:#f92672;">?</span><span>;
</span><span>                println!(</span><span style="color:#e6db74;">&quot;Read </span><span style="color:#ae81ff;">{}</span><span style="color:#e6db74;"> bytes&quot;</span><span>, n);
</span><span>                out.</span><span style="color:#66d9ef;">extend_from_slice</span><span>(</span><span style="color:#f92672;">&amp;</span><span>buf[</span><span style="color:#f92672;">..</span><span>n]);
</span><span>            },
</span><span>
</span><span>            status </span><span style="color:#f92672;">=</span><span> child.</span><span style="color:#66d9ef;">wait</span><span>() </span><span style="color:#f92672;">=&gt; </span><span>{
</span><span>                status</span><span style="color:#f92672;">?</span><span>;
</span><span>                println!(</span><span style="color:#e6db74;">&quot;Child exited!&quot;</span><span>);
</span><span>                </span><span style="color:#f92672;">break &#39;weee
</span><span>            },
</span><span>        }
</span><span>    }
</span><span>    println!(</span><span style="color:#e6db74;">&quot;</span><span style="color:#ae81ff;">{}</span><span style="color:#e6db74;">&quot;</span><span>, </span><span style="font-style:italic;color:#66d9ef;">String</span><span>::from_utf8(out)</span><span style="color:#f92672;">?</span><span>);
</span><span>
</span><span>    println!(</span><span style="color:#e6db74;">&quot;Ok we&#39;re gonna return now&quot;</span><span>);
</span><span>    </span><span style="font-style:italic;color:#66d9ef;">Ok</span><span>(())
</span><span>}
</span></code></pre>
<p><em>sweating profusely</em></p>
<pre style="background-color:#272822;color:#c9d1d9;"><code><span>$ RUSTFLAGS=&quot;--cfg tokio_unstable&quot; cargo run
</span><span>   Compiling terminus v0.1.0 (/home/maya/dev/terminus)
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 3.76s
</span><span>     Running `target/debug/terminus`
</span><span>[src/main.rs:28] primary_fd = 9
</span><span>[src/main.rs:28] secondary_fd = 10
</span><span>Read 51 bytes
</span><span>Read 77 bytes
</span><span>Read 84 bytes
</span><span>Read 84 bytes
</span><span>Read 84 bytes
</span><span>Child exited!
</span><span>    Checking tokio-fd v0.3.0
</span><span>    Checking terminus v0.1.0 (/home/maya/dev/terminus)
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
</span><span>
</span><span>Ok we&#39;re gonna return now
</span><span>
</span><span>$
</span></code></pre>
<p>Hey, look! It works! Without any manual <code>^C</code>! And it's not even ugly! And we even
got rid of that unsafe block around <code>File::from_raw_fd</code>.</p>
<p>I don't know about you, but I'm pretty satisfied with that.</p>
<p>Fixing this upstream in Tokio is left, as an exercise, to the reader.</p>
<div id="get-notified">
    <h1>Enjoyed this article?</h1>
    <p>You might like my <a href="/">other posts</a>, too. If you'd like to be notified
    of new ones, you can <a href="https://donotsta.re/mei">follow me on the Fediverse</a>
    or subscribe to the <a href="/rss.xml">RSS feed</a>.</p>
    <p>I would like to thank
    <a href="https://github.com/sponsors/meithecatte">my GitHub sponsors</a> for their support:
    Michalina Sidor, Tijn Kersjes and LunNova.
    </p>
</div>
<hr />
<div class="footnote-definition" id="yesterday"><sup class="footnote-definition-label">1</sup>
<p>The reader is advised to compare the date on the two articles.</p>
</div>




<noscript>
    This is where the comments would load if you enabled JavaScript.
</noscript>
<script src="https://utteranc.es/client.js"
        repo="meithecatte/compilercrim.es"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>


                <center>
                    <p>
                        Fedi: <a href="https://donotsta.re/mei">@mei@donotsta.re</a>
                        &bull;
                        GitHub: <a href="https://github.com/meithecatte">@meithecatte</a>
                        &bull;
                        E-mail: catch-all on this domain
                    </p>

                    <a href="https://diyhrt.wiki">
                        <img src="/e2.gif" width="88" height="31" />
                    </a>
                </center>
            </article>
            


        </main>
    </body>
    <script type="text/javascript" src="/enhance.js" async></script>
    <script data-goatcounter="https://niedzejkob.goatcounter.com/count" async src="https://compilercrim.es/count.js"></script>
</html>
